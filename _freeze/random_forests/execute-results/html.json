{
  "hash": "4271f076839692352ffd76879e8a502c",
  "result": {
    "markdown": "---\ntitle: \"Random Forest for Data Integration\"\nauthor: \"Payam Emami\"\nformat:\n  html:\n    toc: true\n    toc-expand: 3\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n## Introduction\n\nIn classical data integration, we would like to use information across different modalities (e.g. transcriptome, proteome and metabolome) to gain more comprehensive insights into the biological systems under study. This type of data can be used for an array of different purposes including but not limited to molecular classification, stratification of patients, outcome predictions and understanding of regulatory processes such as gene regulation and pathway analysis.\n\nIn this specific context, we are going to focus on outcome prediction modeling and segmentation, which are promising because each type of omics data may contribute valuable information for the prediction of phenotypic outcomes. More specifically we are going to focus on supervised and unsupervised data integration wherein we have obtained patient data for which several types of omics data are available for the same samples (e.g. patients). We are going to use Random Forest to model the complex relationships between various data types and the outcomes. Random Forest is particularly suited for this task due to its ability to handle high-dimensional and heterogeneous data as well as its ability to and capture intricate, non-linear interactions.\n\nBriefly, in this tutorial we will: \n\n- briefly introduce Random Forest algorithm to predict the outcome of cancer molecular subtype given individual omic data set, such as miRNA, mRNA or proteomics.\n- expand upon Random Forest and learn about Block Forests algorithm to integrate multiple omics to improve classification of cancer molecular subtypes and find top features driving the classification.\n\nTo do so, we need to set-up up our environment\n\n::: {.cell}\n\n```{.r .cell-code}\n# list of packages to be installed\npackages <- c(\"ggplot2\", \"randomForest\", \"blockForest\",\"cluster\",\"gplots\",\"mclust\")\n\n# check and install missing packages\nnew_packages <- packages[!(packages %in% installed.packages()[,\"Package\"])]\nif(length(new_packages)) install.packages(new_packages, dependencies = TRUE, type = \"binary\")\n\n# load the libraries\nlibrary(ggplot2)\nlibrary(randomForest)\nlibrary(blockForest)\n```\n:::\n\n\n# Random Forest\n\nBefore diving into data integration, let's recap what Random Forest is and the basic concepts behind it (for more in-depth review of Random Forest, see [here](http://payamemami.com/randomforest-basics/ \"Random Forest basics\")). Random Forest is an ensemble learning method that operates by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (for the classification task) or mean prediction (for regression taks) of the individual trees.\n\n## Decision Trees\n\nRandom Forest is built upon decision trees, which are tree-like models of decisions based on features' values leading to a prediction about the target variable.\n\n\n```{mermaid}\n%%| fig-align: center\n\ngraph TB\n  A[\"Is feature X > 5?\"] -- Yes --> B[\"Is feature Y > 7?\"]\n  B -- Yes --> C[\"Class A\"]\n  B -- No --> D[\"Class B\"]\n  A -- No --> E[\"Is feature Z > 3?\"]\n  E -- Yes --> F[\"Class C\"]\n  E -- No --> G[\"Class D\"]\n  \n```\n\n\nEach node in the tree corresponds to a feature, and the splitting of nodes is based on measures like entropy or Gini impurity for classification, and variance reduction for regression.\n\n## Bagging & Feature Randomness\n\nRandom Forest improves the performance and accuracy of decision trees through bagging. It creates multiple subsets of the dataset using bootstrap sampling, and a decision tree is built for each subset. The predictions of all trees are then aggregated through majority voting (classification) or averaging (regression) to give the final output.\n\nIn addition to data sampling, Random Forest selects a random subset of features at each split, introducing feature randomness, and resulting in diverse trees. This randomness ensures that the model is robust and less prone to overfitting.\n\n\n```{mermaid}\n%%| fig-align: center\n\ngraph LR\n  RF[\"Data\"] --> B[\"Bagging\"]\n  B --> S[\"Subsets of Dataset\"]\n  B --> FR[\"Feature Randomness\"]\n  S --> BS[\"Bootstrap Sampling\"]\n  FR --> DT\n  BS --> DT[\"Diverse Trees (Random Forest)\"]\n\n```\n\n\n## Advantages of Random Forest\n\nRandom Forest is known for its robustness and high accuracy and it efficiently handles large data sets with higher dimensionality. It can manage missing values and can also provides estimates of feature importance, enabling insights into the driving factors behind predictions. The algorithm is less likely to overfit than individual decision trees, thanks to the diversity introduced by training on different subsets of data and feature randomness. Finally, Random Forest does not make any underlying assumptions about the distribution or the functional form of the data. It is these characteristics that imparts Random Forest with significant flexibility, making it adaptable to a wide array of data distributions and structures.\n\n## Perform Random Forest in R\n\nThere are many packages for Random Forest. We have been using `randomForest` package in R that does implementsBreiman and Cutler's Random Forests algorithm and it is good enough for most of the applications. There are other packages that you can check out such as `ranger` that is a fast implementation of Random Forests, particularly suited for high dimensional data. Here we go through `randomForest` package briefly.\n\n### Data\n\nOur data has to be in a data.frame where features are in the columns and samples in the rows. The categorical variables should preferably be a `factor`. For now we are going to use TCGA dataset from mixOmics.\n\n> *This data set is a small subset of the full data set from The Cancer Genome Atlas that can be analysed with the DIABLO framework. It contains the expression or abundance of three matching omics data sets: mRNA, miRNA and proteomics for 150 breast cancer samples (with three molecular subtypes of breast cancer: Basal, Her2, Luminal A) in the training set, and 70 samples in the test set. The test set is missing the proteomics data set.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download the dataset\ndownload.file(\"https://github.com/mixOmicsTeam/mixOmics/raw/master/data/breast.TCGA.rda\", destfile = \"TCGA.rda\")\n\n# load the data\nload(\"TCGA.rda\")\n```\n:::\n\n\nThis data has already been split into a list with two elements: training and testing. The first element (training) contains four elements, again lists, containing miRNA, mRNA, proteomics and cancer molecular subtypes. The second element (testing) contains three lists holding miRNA, mRNA and molecular subtypes data (proteomics data are missing here).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(breast.TCGA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ data.train:List of 4\n  ..$ mirna  : num [1:150, 1:184] 11.8 12.9 12.3 12 13.4 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:150] \"A0FJ\" \"A13E\" \"A0G0\" \"A0SX\" ...\n  .. .. ..$ : chr [1:184] \"hsa-let-7a-1\" \"hsa-let-7a-2\" \"hsa-let-7a-3\" \"hsa-let-7b\" ...\n  ..$ mrna   : num [1:150, 1:200] 4.36 1.98 1.73 4.36 2.45 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:150] \"A0FJ\" \"A13E\" \"A0G0\" \"A0SX\" ...\n  .. .. ..$ : chr [1:200] \"RTN2\" \"NDRG2\" \"CCDC113\" \"FAM63A\" ...\n  ..$ protein: num [1:150, 1:142] 0.0491 -0.08 -0.0328 -0.2053 0.0602 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:150] \"A0FJ\" \"A13E\" \"A0G0\" \"A0SX\" ...\n  .. .. ..$ : chr [1:142] \"14-3-3_epsilon\" \"4E-BP1\" \"4E-BP1_pS65\" \"4E-BP1_pT37\" ...\n  ..$ subtype: Factor w/ 3 levels \"Basal\",\"Her2\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ data.test :List of 3\n  ..$ mirna  : num [1:70, 1:184] 12.8 13.9 12.9 12.4 13.1 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:70] \"A54N\" \"A2NL\" \"A6VY\" \"A3XT\" ...\n  .. .. ..$ : chr [1:184] \"hsa-let-7a-1\" \"hsa-let-7a-2\" \"hsa-let-7a-3\" \"hsa-let-7b\" ...\n  ..$ mrna   : num [1:70, 1:200] 1.19 2.73 3.05 2.7 3.14 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:70] \"A54N\" \"A2NL\" \"A6VY\" \"A3XT\" ...\n  .. .. ..$ : chr [1:200] \"RTN2\" \"NDRG2\" \"CCDC113\" \"FAM63A\" ...\n  ..$ subtype: Factor w/ 3 levels \"Basal\",\"Her2\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n:::\n\n\n### Modeling (running RF)\nNow we can go ahead and do the modeling. Let's use miRNA data to build a model predicting the cancer molecular subtypes.\n\n::: {.cell}\n\n```{.r .cell-code}\n# set the seed for reproduciblity\nset.seed(123)\n\n# run the model\nrf_mirna <- randomForest::randomForest(breast.TCGA$data.train$mirna,\n                                      y = breast.TCGA$data.train$subtype, keep.forest=T)\n```\n:::\n\n\nLet's have a look at the results\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(rf_mirna)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\n randomForest(x = breast.TCGA$data.train$mirna, y = breast.TCGA$data.train$subtype,      keep.forest = T) \n               Type of random forest: classification\n                     Number of trees: 500\nNo. of variables tried at each split: 13\n\n        OOB estimate of  error rate: 15.33%\nConfusion matrix:\n      Basal Her2 LumA class.error\nBasal    40    2    3  0.11111111\nHer2      5   14   11  0.53333333\nLumA      0    2   73  0.02666667\n```\n:::\n:::\n\n\nThe output tells us that the model was initiated with the **`randomForest()`** function, using the miRNA data as predictors (x) and the cancer subtypes as the response (y). It is a classification type model, as indicated.\n\nThe model is composed of 500 trees (\"Number of trees: 500\"), and at each decision split in the trees, 13 variables or features were randomly selected and assessed to identify the optimal split (\"No. of variables tried at each split: 13\").\n\nThe Out-Of-Bag (OOB) error estimate is 15.33%. OOB error is a unique feature of Random Forest: it provides an internal validation mechanism. During the training of each tree, a subset of the data is left out (not sampled) and used to validate the tree, giving an error estimate. This OOB error is particularly useful as it offers an unbiased performance metric without the need for cross-validation or a separate test set. In this case, the 15.33% OOB error rate means the model is expected to misclassify (incorrectly predict) approximately 15.33% of new samples, offering a glimpse into the model's accuracy without a separate validation set.\n\nThe confusion matrix for the training set reveals detailed class-specific performance. For the 'Basal' subtype, the model achieved a classification error rate of 11.11%, with 40 correct predictions. The 'Her2' subtype encountered a higher classification error rate of 53.33%, resulting from a substantial number of misclassifications. In contrast, the 'LumA' subtype exhibited impressive accuracy, with a mere 2.67% error rate and 73 correct classifications.\n\nWe can go ahead and check the performance of the model on the test, unseen so far, data.\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions_mirna <- randomForest:::predict.randomForest(rf_mirna,\n                                                         breast.TCGA$data.test$mirna)\n# create a confusion matrix\nconf_matrix <- table(breast.TCGA$data.test$subtype, predictions_mirna)\n\n# print the confusion matrix\nprint(conf_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       predictions_mirna\n        Basal Her2 LumA\n  Basal    19    1    1\n  Her2      3    6    5\n  LumA      0    2   33\n```\n:::\n\n```{.r .cell-code}\n# calculate the class error rates\nclass_error <- 1 - diag(conf_matrix) / rowSums(conf_matrix)\n\n# calculate the overall error rate\noverall_error_rate <- (sum(conf_matrix) - sum(diag(conf_matrix))) / sum(conf_matrix)\n\n# print class error rates\nprint(class_error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Basal       Her2       LumA \n0.09523810 0.57142857 0.05714286 \n```\n:::\n\n```{.r .cell-code}\n# print overall error rate\nprint(overall_error_rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1714286\n```\n:::\n:::\n\n\nSo we have about 17.14% error rate in miRNA. How much error we have in mRNA?\n\n::: {#exr-mRNA}\n## mRNA\n\nFit a model for mRNA and check the error on the test set.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nset.seed(123)\nrf_mrna <- randomForest::randomForest(breast.TCGA$data.train$mrna,\n                                      y = breast.TCGA$data.train$subtype, keep.forest=T)\nprint(rf_mrna)\n\npredictions_mrna <- randomForest:::predict.randomForest(rf_mrna,\n                                                         breast.TCGA$data.test$mrna)\n# create a confusion matrix\nconf_matrix <- table(breast.TCGA$data.test$subtype, predictions_mrna)\n\n# print the confusion matrix\nprint(conf_matrix)\n\n# calculate the class error rates\nclass_error <- 1 - diag(conf_matrix) / rowSums(conf_matrix)\n\n# calculate the overall error rate\noverall_error_rate <- (sum(conf_matrix) - sum(diag(conf_matrix))) / sum(conf_matrix)\n\n# print class error rates\nprint(class_error)\n\n# print overall error rate\nprint(overall_error_rate)\n```\n:::\n\n\n## Hyperparameters\n\nThere are some parameters that need tuning to get better performance from Random Forest.\n\nTwo of the most important parameters are:\n\n### 1. Number of Trees {.unnumbered .unlisted}\n\nThis parameter specifies the total count of trees in the forest. Each tree contributes to the final decision, making a vote for classifying an object or predicting a continuous value.\n\n-   Tuning Guidance:\n\n    -   A larger number of trees typically offers better learning capability and is less likely to overfit, but it also means higher computational cost.\n\n    -   It's often recommended to try a range of values to find a good balance between performance and computational efficiency. There's usually a threshold beyond which increasing the number of trees doesn't offer significant benefits in terms of prediction accuracy.\n\n    -   A common practice is to start with a moderate number of trees and increase it until the error rate stabilizes.\n\n### 2. Number of Features Considered at Each Split {.unnumbered .unlisted}\n\nThis parameter determines the maximum number of features considered for splitting at each node. Random Forest involves randomly selecting a subset of features at each split, introducing diversity among the trees and making the model robust.\n\n-   Tuning Guidance:\n\n    -   For classification, it's common to start with the square root of the total number of features. For regression, using one-third of the total features is a common starting point.\n\n    -   Tuning this parameter can help manage the bias-variance trade-off. A smaller number of features can increase the diversity among trees (reducing variance) but might also introduce bias. Conversely, considering more features can reduce bias but might lead to overfitting (increased variance).\n\n    -   Experimenting with different values through techniques like grid search or random search can help identify the optimal number of features for your specific dataset and problem.\n\nWe are going to skip tuning for now to focus on the data integration with Random Forest.\n\n# Data Integration using Random Forests\n\nOne of the major issues that needs to be addressed when it comes to data integration is data distribution. Biological data come with different distributions and that make it unsuitable to simply concatenate RNASeq and proteomics data and perform a regression or classification for most of the methods. However, as mentioned before Random Forest does not make any assumptions about the data distribution. Because of this, it is possible to merge the data and perform the analysis on the entire data.\n\n::: {#exr-merge}\n## mRNA and miRNA\n\nMerge mRNA and miRNA data sets, do the modelling using Random Forest and calculate the performance on the merged test data.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nset.seed(123)\n\ndata_train_mirna_mrna <- cbind(breast.TCGA$data.train$mrna, breast.TCGA$data.train$mirna)\ndata_test_mirna_mrna <- cbind(breast.TCGA$data.test$mrna, breast.TCGA$data.test$mirna)\n\nrf_mirna_mrna <- randomForest::randomForest(data_train_mirna_mrna,\n                                      y = breast.TCGA$data.train$subtype, keep.forest=T)\nprint(rf_mirna_mrna)\n\npredictions_mirna_mrna <- randomForest:::predict.randomForest(rf_mirna_mrna, \n                                                         data_test_mirna_mrna)\n# create a confusion matrix\nconf_matrix <- table(breast.TCGA$data.test$subtype, predictions_mirna_mrna)\n\n# print the confusion matrix\nprint(conf_matrix)\n\n# calculate the class error rates\nclass_error <- 1 - diag(conf_matrix) / rowSums(conf_matrix)\n\n# calculate the overall error rate\noverall_error_rate <- (sum(conf_matrix) - sum(diag(conf_matrix))) / sum(conf_matrix)\n\n# print class error rates\nprint(class_error)\n\n# print overall error rate\nprint(overall_error_rate)\n```\n:::\n\nOne of the issues with naively concatenating the data sets and do Random Forest is that data views that have fewer variables are underrepresented in the variable splitting. This means that for example if we are to combine clinical data with 20 variables such as age, gender, or BMI and methylation data with 2 million CpG sites, the clinical variables will have a very little chance of being selected for split in each tree, and consequently will not contribute to the predictive performance of the model, even though we may know that age is driving the genome-wide DNA methylation alterations. Another issue is that even if we have the data sets (views) with similar sizes, one data view can have significantly higher information content that others. It is reasonable to give more priority to the modalities that can give us more accurate predictions. `blockForest` is the name of one of the algorithms that allows us to take into account the block structure of the data in an intuitive way leading to much more sound algorithm that simply concatenating the data.\n\n## BlockForest\n\nBlockForest is a machine learning technique specifically tailored for handling multi-omics data. In BlockForest, the data is divided into different \"blocks,\" each representing a different type of omics data.\n\n### How Does BlockForest Work?\n\n1.  Block Selection:\n\n-   The first step in BlockForest involves randomly selecting a subset of all available blocks of data. Each block is chosen with a probability of 0.5. If no block is selected, the process is repeated until at least one block is chosen.\n\n$$\nP(\\text{selecting block } m) = 0.5, \\quad \\forall m \\in M \n$$ 2. Variable Sampling:\n\nAfter the blocks are selected, variables from these blocks are sampled. The number of variables sampled from each block is proportional to the square root of the total number of variables in that block.\n\n$$\n\\text{Sampled variables from block } m = \\sqrt{p_m}, \\quad \\forall m \\in \\text{selected blocks} \n$$ 3. Split Point Selection with Weights:\n\nThe next step involves selecting split points for creating decision trees, similar to the random forest algorithm. However, in BlockForest, the split criterion values are weighted using block-specific weights.\n\nIf ($w_m$) is the weight for block ($m$), and ($SC_m$) is the split criterion value for a potential split point in block ($m$), the weighted split criterion value is calculated as:\n\n$$\n  \\text{Weighted SC} = \\max(w_m \\times SC_m), \\quad \\forall m \\in \\text{selected blocks}\n  $$\n\nThe split point chosen is the one that gives the highest weighted split criterion value.\n\n4.  Tree Construction:\n\n-   Decision trees are then constructed using the selected split points. Each tree in the forest is built using a different subset of the data and variables, leading to a diverse set of trees.\n\n5.  Prediction:\n\n-   For prediction, each tree in the BlockForest votes, and the final prediction is made based on the majority vote.\n\nSo by randomly selecting blocks and variables, BlockForest ensures a diverse set of trees, leading to a more robust model. It ensures that each block of omics data is adequately represented.\n\n### Parameter Tuning\n\nTuning parameters in BlockForest is crucial to optimize the model's performance. Each block has associated tuning parameters, and these need to be optimized to ensure the model is as accurate and generalizable as possible.\n\nHere's how the tuning is done:\n\n1.  Generation of Random Sets:\n    -   Generate $N_{\\text{sets}}$ random sets of $M$ tuning parameter values.\n    -   Construct a forest with a predefined number of trees using each set of tuning parameter values.\n    -   Record the out-of-bag prediction error for each forest.\n\nMathematically, for each iteration $i$, a random set $\\Lambda_i$ of $M$ tuning parameter values is generated:\n\n$$ \\Lambda_i = \\{ \\lambda_{i1}, \\lambda_{i2}, \\ldots, \\lambda_{iM} \\}, \\quad i = 1, \\ldots, N_{\\text{sets}} $$\n\n2.  Selection of Optimal Set:\n    -   Select the set of tuning parameter values that resulted in the smallest out-of-bag prediction error.\n\nThe optimal set $\\Lambda^*$ is given by:\n\n$$ \\Lambda^* = \\arg\\min_{\\Lambda_i} \\text{Error}(\\Lambda_i), \\quad i = 1, \\ldots, N_{\\text{sets}} $$\n\nwhere $\\text{Error}(\\Lambda_i)$ is the out-of-bag prediction error associated with the $i$-th set of tuning parameter values.\n\n### Performing data integration using blockForest\n\nWe continue using our previous dataset. The main function for performing data integration in blockForest is `blockfor`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# merge the data first \nmerge_data <- cbind(breast.TCGA$data.train$mirna,\n                    breast.TCGA$data.train$mrna)\n\n# create block structure\nblocks <- rep(c(1,2), times=c(ncol(breast.TCGA$data.train$mirna),ncol(breast.TCGA$data.train$mrna)))\nblocks <- lapply(1:2, function(x) which(blocks==x))\n\nset.seed(123)\nmerged_model <- blockForest::blockfor(merge_data, breast.TCGA$data.train$subtype, blocks=blocks,\n                        block.method = \"BlockForest\", num.trees = 500, importance=\"permutation\")\n```\n:::\n\n\nWe can have a look at the output\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(merged_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$forest\nblockForest result\n\nCall:\n blockForest(dependent.variable.name = \"y\", data = model.data,      num.trees = num.trees, blocks = blocks, block.weights = paramvalues,      mtry = mtry, keep.inbag = TRUE, block.method = block.method,      splitrule = splitrule, always.split.variables = always.split.variables,      ...) \n\nType:                             Classification \nNumber of trees:                  500 \nSample size:                      150 \nNumber of independent variables:  384 \nMtry:                             13 14 \nTarget node size:                 1 \nVariable importance mode:         permutation \nOOB prediction error:             8.67 % \n\n$paramvalues\n[1] 0.5911938 1.0000000\n\n$biased_oob_error_donotuse\n[1] 0.08666667\n```\n:::\n:::\n\n\nThis is a similar output to the one we have seen before. The differences are:\n\n1.  Mtry: 13 14\n\n    -   `Mtry` refers to the number of variables randomly sampled at each split when building the trees. Here, two values are provided, indicating two different blocks of features with different `mtry` values.\n\n2.  OOB prediction error: 8.67%\n\n    -   Out-Of-Bag (OOB) error is a method of measuring the prediction error of random forests, bagging, and boosting classifiers. Here, it shows that the model has an OOB error rate of 8.67%, meaning it incorrectly classified around 8.67% of the samples during training.\n\n3.  \\$paramvalues\n\n    -   0.5911938, 1: These are the optimized parameter values associated with each block of features. They are obtained through the parameter tuning process and are used to weight the blocks during model training.\n\nSince the OOBs have been used for doing parameter tunning, we cannot use them to evaluate the model. we will have to do cross-validation. We leave this for later and continue with the prediction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# merge the test data\nmerged_data_test <- cbind(breast.TCGA$data.test$mirna,\n                                     breast.TCGA$data.test$mrna)\ncolnames(merged_data_test) <- gsub(\"-\", \".\", colnames(merged_data_test))\n\n# get the prediction\nintegrative_predictions <- blockForest:::predict.blockForest(merged_model$forest,\n                                  data = merged_data_test)\n\n# create a confusion matrix\nconf_matrix <- table(breast.TCGA$data.test$subtype, integrative_predictions$predictions)\n\n# print the confusion matrix\nprint(conf_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       \n        Basal Her2 LumA\n  Basal    20    1    0\n  Her2      1    9    4\n  LumA      0    0   35\n```\n:::\n\n```{.r .cell-code}\n# calculate the class error rates\nclass_error <- 1 - diag(conf_matrix) / rowSums(conf_matrix)\n\n# calculate the overall error rate\noverall_error_rate <- (sum(conf_matrix) - sum(diag(conf_matrix))) / sum(conf_matrix)\n\n# print class error rates\nprint(class_error)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Basal       Her2       LumA \n0.04761905 0.35714286 0.00000000 \n```\n:::\n\n```{.r .cell-code}\n# print overall error rate\nprint(overall_error_rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.08571429\n```\n:::\n:::\n\n\nSo we have obtained a prediction accuracy. **Is it better or worse compared to separate modelling of the data sets?**\n\n### Visualize the Random Forest subspace\n\nRandom Forest does not only give accuracy estimates but a lot more information that can be used to visualize and further analyze their internals.\n\nOne of the useful pieces of information is called proximities. Random Forest proximity measures are a valuable tool for understanding the similarity between data points within a data set. When a Random Forest model is trained, each tree in the forest classifies each data point into a specific leaf node. The proximity measure between two data points is calculated based on the frequency with which they end up in the same leaf node across all trees in the forest. In other words, the more often two data points are classified into the same leaf node, the higher their proximity measure, indicating a higher level of similarity. This measure can be normalized and used for various purposes, such as data clustering, outlier detection, and missing value imputation and it thus provides insights into the underlying structure and relationships within the data.\n\nLet's try to extract proximity measures for the training and testing data sets.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# load plotting library\nlibrary(ggplot2)\n\n# reformat col names: change \"-\" to \".\"\ncolnames(merge_data) <- gsub(\"-\", \".\", colnames(merge_data))\n\n# get node labels\nnodes<-blockForest:::predict.blockForest (merged_model$forest,data =merge_data ,type=\"terminalNodes\")\nnode_labels_training <- nodes$predictions\n\n# initiate empty proximity matrix\nn_samples <- nrow(merge_data)\nproximity_matrix <- matrix(0, nrow=n_samples, ncol=n_samples)\n\ninbag = simplify2array(merged_model$forest$inbag.counts)\n# Compute the proximity matrix\nfor (i in seq_len(n_samples)) {\n  for (j in seq_len(n_samples)) {\n    tree_idx = inbag[i, ] == 0 & inbag[j, ] == 0\n    proximity_matrix[i, j] <- sum(node_labels_training[i,tree_idx] == node_labels_training[j,tree_idx]) / sum(tree_idx)\n  }\n}\n\n# convert to distances\ndistances <- 1 - (proximity_matrix)\n\n# do MDS\nrf.mds <- stats::cmdscale(distances, eig = TRUE, k = 2)\n\n# plot MDS\ndata_points <- rf.mds$points\ndata_points <- cbind.data.frame(data_points,groups=as.character(breast.TCGA$data.train$subtype),dataset=\"training\")\nnames(data_points) <- c(\"p1\",\"p2\",\"groups\",\"dataset\")\n\n## perform the same for the test set\nnodes <- blockForest:::predict.blockForest (merged_model$forest,data =merged_data_test ,type=\"terminalNodes\")\nnode_labels_test <- nodes$predictions\n\n# empty proximity matrix\nn_samples <- nrow(merged_data_test)\nproximity_matrix <- matrix(0, nrow=n_samples, ncol=n_samples)\n\n# get in bag samples\ninbag = simplify2array(merged_model$forest$inbag.counts)\n# Compute the proximity matrix\nfor (i in seq_len(n_samples)) {\n  for (j in seq_len(n_samples)) {\n    proximity_matrix[i, j] <- sum(node_labels_test[i,] == node_labels_test[j,])\n  }\n}\n\n# convert to distances\ndistances <- 1 - (proximity_matrix)/merged_model$forest$num.trees\n# do MDS\nrf.mds <- stats::cmdscale(distances, eig = TRUE, k = 2)\n\n# plot MDS\ndata_points_test <- rf.mds$points\ndata_points_test <- cbind.data.frame(data_points_test, groups=as.character(breast.TCGA$data.test$subtype), dataset=\"test\")\nnames(data_points_test) <- c(\"p1\",\"p2\",\"groups\",\"dataset\")\n\nggplot(rbind(data_points,data_points_test)) + \n  geom_point(aes(x=p1, y=p2, color=groups, shape=dataset))\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nUsing multidimensional scaling, we have collapsed the dataset to a set of lower dimensions that preserve the overall distance between the data points.\n\n### Variable importance\n\nSimilar to regular Random Forest, blockForest also gives us variable importance. In the function call we have selected permutation based importance.\n\nWe can go ahead and explore these to select the most important variables that discriminate the groups.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# extract the importance and add to a data frame together with modality information\nimportance_measure_integration <- data.frame(features = names(merged_model$forest$variable.importance),\n                                             importance = merged_model$forest$variable.importance,\n           modality =  rep(c(\"mirna\",\"mrna\"), times=c(ncol(breast.TCGA$data.train$mirna),ncol(breast.TCGA$data.train$mrna))))\n\n# sort the importance\nimportance_measure_integration <- \n  importance_measure_integration[order((importance_measure_integration[,2]),decreasing = T),]\n\n# only show top 30\nggplot(importance_measure_integration[1:30,], \n       aes(x = reorder(features, importance), y = importance, fill = modality)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  labs(x = \"Gene\", y = \"Importance\", fill = \"Modality\") +\n  theme_minimal() +\n  scale_fill_manual(values = c(\"mirna\" = \"skyblue\",\"mrna\"=\"red\"))\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n### Unsupervised data integration\n\nRandom Forest algorithm is inherently supervised but its flexibility allows us to perform unsupervised data integration with it. In order to do that, we are going to do a simple trick. We are going to shuffle our data to create a synthetic copy of our original data. We are then going to perform the modelling such that the model differentiate between the real and synthetic copy. After than we can go ahead with the distance calculations etc.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# merge the data first \nmerge_data <- cbind(breast.TCGA$data.train$mirna,\n                    breast.TCGA$data.train$mrna)\n\nsynth <- apply(merge_data,2, function(x) {\n  sample(x, length(x), replace = TRUE)\n})\n\nx <- rbind(merge_data, synth)\ny <- factor(c(rep(1, nrow(merge_data)), rep(2, nrow(merge_data))))\n\n# create block structure\nblocks <- rep(c(1,2), times=c(ncol(breast.TCGA$data.train$mirna),ncol(breast.TCGA$data.train$mrna)))\nblocks <- lapply(1:2, function(x) which(blocks==x))\n\nset.seed(123)\nmerged_model <- blockForest::blockfor(x, y, blocks=blocks,\n                        block.method = \"BlockForest\",num.trees = 500)\n\n# reforman column names\ncolnames(merge_data) <- gsub(\"-\", \".\", colnames(merge_data))\n\n# get node labels\nnodes<-blockForest:::predict.blockForest (merged_model$forest, data=merge_data, type=\"terminalNodes\")\nnode_labels_training <- nodes$predictions\n\n# initiate empty proximity matrix\nn_samples <- nrow(merge_data)\nproximity_matrix <- matrix(0, nrow=n_samples, ncol=n_samples)\n\ninbag = simplify2array(merged_model$forest$inbag.counts)\n# compute the proximity matrix\nfor (i in seq_len(n_samples)) {\n  for (j in seq_len(n_samples)) {\n    tree_idx = inbag[i, ] == 0 & inbag[j, ] == 0\n    proximity_matrix[i, j] <- sum(node_labels_training[i,tree_idx] == node_labels_training[j,tree_idx]) / sum(tree_idx)\n  }\n}\n\n# convert to distances\ndistances <- 1 - (proximity_matrix)\n\n# do MDS\nrf.mds <- stats::cmdscale(distances, eig = TRUE, k = 2)\n\n# plot MDS\ndata_points <- rf.mds$points\ndata_points <- cbind.data.frame(data_points,groups=as.character(breast.TCGA$data.train$subtype))\nnames(data_points) <- c(\"p1\",\"p2\",\"groups\")\nggplot(rbind(data_points))+geom_point(aes(x=p1, y=p2, color=groups))\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nNow given that we can use Random Forest for unsupervised distance calculation, we now proceed with clustering of the variables we have selected in the supervised part (top 30 variables):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\nRF_variables<-randomForest::randomForest(t(merge_data[,importance_measure_integration[1:30,]$features]))\n\nrf.mds <- stats::cmdscale(1-RF_variables$proximity, eig = TRUE, k = 2)\nplot(rf.mds$points,type=\"n\")\ntext(rf.mds$points,rownames(rf.mds$points))\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nIn the code above, we used `randomForest` package to do unsupervised clustering. **Can you guess why we did not use `blockForest`**?\n\nThe results of `randomForest` contain the proximity matrix which can use as a proxy to distance between the features in the random forest space. We can now use this proximity matrix to perform clustering of relevant features.\n\nIn order to perform clustering, we are going to use the `pam` (Partitioning Around Medoids) algorithm. We use `pam` because it supports distance matrix, which means it can take the proximity matrix generated by `randomForest` and use it as a base to determine the distance between clusters. The way `pam` works is by initially selecting data points called medoids from the dataset. These medoids serve as the center of clusters. During the iterative optimization process, the algorithm assesses and swaps medoids with non-medoid data points to minimize the sum of the distances between the data points and their corresponding medoids. One of the main benefits of using `pam` over other clustering algorithms is its robustness to outliers. Since it uses medoids (actual data points) as the center of clusters, instead of mean values like in k-means, it is less influenced by extreme values. Moreover, `pam` is known for producing more accurate and consistent clusters, especially when the dataset has noise and outliers. Another advantage is its interpretability; by using actual data points as representatives, it is easier to understand and explain the characteristics of each cluster. All these attributes make `pam` a suitable choice for clustering features based on the proximity matrix from `randomForest`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfeatures_pam <- cluster::pam(1-RF_variables$proximity,3)\nplot(rf.mds$points,type=\"n\")\ntext(rf.mds$points,rownames(rf.mds$points),col=features_pam$clustering)\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nHaving identified `pam` as our clustering algorithm of choice, the next critical step is determining the optimal number of clusters. A standard and effective technique for this purpose is the silhouette method. The silhouette score measures how similar an object is to its own cluster compared to other clusters. Values range between -1 and 1, with a high value indicating that the object is well matched to its own cluster and poorly matched to neighboring clusters. By plotting the silhouette scores for different numbers of clusters, we can visually inspect and select the number that gives the highest silhouette score, thus ensuring optimal cluster cohesion and separation. The code snippet provided demonstrates the application of `pam` on the `randomForest` proximity matrix for a specified number of clusters, in this case, three. By iterating over different cluster counts and assessing their silhouette scores, we can confidently determine the most appropriate number of clusters for our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate silhouette widths for different number of clusters\nsil_width <- sapply(2:10, function(k) {\n  pam_fit <- cluster::pam(1-RF_variables$proximity, k)\n  mean(cluster::silhouette(pam_fit)[,\"sil_width\"])\n})\nsil_width<-c(0,sil_width)\n# Plot the silhouette scores\nplot(1:10, sil_width, type='b', xlab='Number of clusters', ylab='Silhouette Width', main='Optimal number of clusters based on Silhouette Width')\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nBy executing the above code, we will obtain a graph that helps in identifying the number of clusters that maximize the silhouette width, providing a clear criterion for cluster selection. **What is the best number of clusters according to Silhouette Width?**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfeatures_pam <- cluster::pam(1-RF_variables$proximity,which.max(sil_width))\nplot(rf.mds$points,type=\"n\")\ntext(rf.mds$points,rownames(rf.mds$points),col=features_pam$clustering)\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nSo given the clustering, we can have a look at a heatmap to check the expression pattern of the data:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# generate colors for clusters\ncluster_colors <- rainbow(length(unique(features_pam$clustering)))\nside_colors <- cluster_colors[features_pam$clustering[order(features_pam$clustering)]]\n\n# generate colors for subtypes\nsubtype_colors <- rainbow(length(unique(breast.TCGA$data.train$subtype)))\nrow_side_colors <- subtype_colors[as.numeric(as.factor(breast.TCGA$data.train$subtype))]\n\n# plot the heatmap\ngplots::heatmap.2(as.matrix(merge_data[,importance_measure_integration[1:30,]$features][,order(features_pam$clustering)]),\n                  notecol=\"black\",      # change font color of cell labels to black\n                  density.info=\"none\",  # turn off density plot inside color legend\n                  trace=\"none\",         # turn off trace lines inside the heatmap\n                  margins = c(12,9),    # space for the labels\n                  col = colorRampPalette(c(\"blue\", \"white\", \"red\"))(25), # color scheme\n                  srtCol = 45,          # rotate column labels\n                  adjCol = c(0.5, 0.5), # center column labels\n                  dendrogram=\"row\",     # only draw a row dendrogram\n                  Colv=F,\n                  cexRow = 0.9,         # size of row labels\n                  cexCol = 0.9,\n                  scale = \"row\",        # size of column labels\n                  ColSideColors = side_colors,RowSideColors =row_side_colors) # Add the column side colors\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=768}\n:::\n:::\n\n\nThe scaled expression pattern more or less shows the our clusters has been effectively capturing the underlining pattern in the data.\n\nThe clustering so far has been on the training set. One question that we can ask is whether we see similar pattern of feature clustering if we perform the same analysis on the test set?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\nRF_variables_test<-randomForest::randomForest(t(merged_data_test[,importance_measure_integration[1:30,]$features]))\n\nrf.mds_test <- stats::cmdscale(1-RF_variables_test$proximity, eig = TRUE, k = 2)\nfeatures_pam_test <- cluster::pam(1-RF_variables_test$proximity,which.max(sil_width))\n\npar(mfrow=c(1,2))\nplot(rf.mds$points,type=\"n\",main=\"Training set\")\ntext(rf.mds$points,rownames(rf.mds$points),col=features_pam$clustering)\n\nplot(rf.mds_test$points,type=\"n\",main=\"Test set\")\ntext(rf.mds_test$points,rownames(rf.mds_test$points),col=features_pam_test$clustering)\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\nJust looking at the plots, the clustering looks very similar. This is a good indication. We can also go one step further and quantify the comparisons of two clusters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a contingency table\ncontingency_table <- table(features_pam$clustering, features_pam_test$clustering)\n\n# convert the table to a data frame for ggplot\ndf <- as.data.frame(as.table(contingency_table))\n\n# create a heatmap\nggplot(data = df, aes(x = Var1, y = Var2)) + \n  geom_tile(aes(fill = Freq), color = \"white\") +\n  geom_text(aes(label = sprintf(\"%d\", Freq)), vjust = 1) +\n  scale_fill_gradient(low = \"white\", high = \"steelblue\") +\n  labs(title = \"Cross-tabulation of Clusters\",\n       x = \"Training Clusters\",\n       y = \"Test Clusters\",\n       fill = \"Count\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](random_forests_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nHere we used a cross-tabulation heatmap, or confusion matrix heatmap, which provides a visual representation of the relationship between two clustering results. In this context, it will show how clusters from the training data correspond to clusters from the test data.\n\nWe can also use other, more formal, measures to say something about the clustering comparison:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"Adjusted Rand Index: \",mclust::adjustedRandIndex(features_pam$clustering, features_pam_test$clustering),\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAdjusted Rand Index:  0.6280206 \n```\n:::\n:::\n\n\nThe Adjusted Rand Index (ARI) is a measure that quantifies the similarity between two data clusterings, accounting for chance grouping of elements. The value of ARI lies between -1 and 1, where an ARI of 1 indicates that the two clusterings are identical, and an ARI of 0 suggests that the clustering result is no better than a random assignment. In our case, the computed ARI provides a numerical assessment of the consistency between our training and test data clusterings. A higher ARI value indicates a closer alignment between the two clusterings. Our ARI is fairly OK which makes us more confident about our selected variables.\n\nThis concludes our lab, but one could go forward with pathway analysis etc. to further explore the underlying biological processes and molecular interactions associated with the identified clusters.\n\n## Summary\n\n- We saw how to use Random Forest for predicting the cancer subtypes given individual miRNA and mRNA data set, where we got overall classification rate ca. 0.17 (miRNA) and 0.057 (mRNA). \n- We learned about Block Forests and saw that when combining miRNA and mRNA data sets the overall classification was ca. 0.085 and that the majority of the top features driving the classification were mRNA based, in line with the Random Forest results, where mRNA features were performing better as individual omics data set. \n- We learned also how to use Random Forest for unsupervised data integration, based on features both from mRNA and miRNA data sets. \n- Remember to tune your model parameters when applying Random Forest or Block Forests to your data, something that we had to leave out from this tutorial, but can be found in many textbooks and online materials. \n\n",
    "supporting": [
      "random_forests_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}